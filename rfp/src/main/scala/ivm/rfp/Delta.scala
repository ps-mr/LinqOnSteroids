package ivm.rfp

import scalaz.Group

trait GenArrow[A, B] {
  def src: A
  def dst: B
}

trait ConcreteGroupoid[T, H <: T, L <: H, =>:[A >: L <: H, B >: L <: H] <: GenArrow[A, B]] {
  def compose[A >: L <: H, B >: L <: H, C >: L <: H](a1: A =>: B, a2: B =>: C): A =>: C
  def id[A >: L <: H]: A =>: A
  def invert[A >: L <: H, B >: L <: H](f : A =>: B): B =>: A
}


trait BaseDelta[T, H <: T, L <: H, DT[A >: L <: H, B >: L <: H] <: GenArrow[A, B]] extends ConcreteGroupoid[T, H, L, DT] {
  def reassemble[A >: L <: H, B >: L <: H](base: A, delta: DT[A, B]): B
}

/**
 * A proxy for an instance of [[Group]].
 */
//TODO: This type should be generated by a proxy type macro.
trait ForwardingGroup[T] extends Group[T] {
  def underlying: Group[T]

  override def append(a: T, b: => T): T = underlying.append(a, b)
  override def inverse(a: T): T = underlying.inverse(a)
  override val zero: T = underlying.zero
}

/**
 * DT is the type of deltas of T.
 */
trait Delta[T, DT] extends Group[DT] {
  def reassemble(base: T, delta: DT): T
}

object Delta extends DeltaValueDefs with DeltaSetDefs {
  implicit def deltaIsItsOwnDelta[T, DT](implicit d: Delta[T, DT]): Delta[DT, DT] = new Delta[DT, DT] with ForwardingGroup[DT] {
    def underlying = d
    def reassemble(base: DT, delta: DT): DT = append(base, delta)
  }
}
