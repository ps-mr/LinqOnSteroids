package ivm.rfp

import scalaz.{Monoid,GeneralizedCategory,GeneralizedGroupoid,Hom}

trait MyCategory[~>:[_,_]] extends GeneralizedCategory {
  trait U extends Hom {
    type L = scalaz.Scalaz.âŠ¥
    type U = Singleton
    type C[A, B] = ~>:[A, B]
  }
}
trait MyGroupoid[~>:[_, _]] extends GeneralizedGroupoid with MyCategory[~>:]

/**
 * A group, as known from abstract algebra.
 *
 * Beyond laws on [[scalaz.Monoid]], this should satisfy one additional law:
 * <code>forall a. append(a, inverse(a)) = append(inverse(a), a) = zero</code>
 */
trait Group[T] extends Monoid[T] {
  def inverse(a: T): T
}

/**
 * A proxy for an instance of [[Group]].
 */
//TODO: This type should be generated by a proxy type macro.
trait ForwardingGroup[T] extends Group[T] {
  def underlying: Group[T]

  override def append(a: T, b: => T): T = underlying.append(a, b)
  override def inverse(a: T): T = underlying.inverse(a)
  override val zero: T = underlying.zero
}

/**
 * DT is the type of deltas of T.
 */
trait Delta[T, DT] extends Group[DT] {
  def embed(t: T): DT
  def reassemble(base: T, delta: DT): T
}

object Delta extends DeltaValueDefs with DeltaSetDefs {
  implicit def deltaIsItsOwnDelta[T, DT](implicit d: Delta[T, DT]): Delta[DT, DT] = new Delta[DT, DT] with ForwardingGroup[DT] {
    def embed(t: DT) = t
    def underlying = d
    def reassemble(base: DT, delta: DT): DT = append(base, delta)
  }
}
