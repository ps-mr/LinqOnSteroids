package ivm.expressiontree

<%
  escapeMarkup = false
  val maxArity = 10
  val commaSpace = ", "
  def baseParLoop(arity: Int)(formatter: Int => String, sep: String = commaSpace) = (1 to arity) map formatter mkString sep
  def defParamsLoop(arity: Int)(sep: String)(formatStr: String) = baseParLoop(arity)(formatStr format _, sep)
  def defParamsLoopComma(arity: Int)(formatStr: String) = defParamsLoop(arity)(commaSpace)(formatStr)

  //def defParamsLoopOld(arity: Int)(formatStr: String, prefix: String, sep: String = commaSpace) = baseParLoop(arity)(formatStr format (prefix, _), sep)
  val tpPfx = "A"
  val subNodePfx = "t"
  val argPfx = "arg"
%>
#for (arity <- 1 to maxArity)
<%
  val paramsLoop = defParamsLoop(arity) _
  val paramsLoopComma = defParamsLoopComma(arity) _

  val tparams = paramsLoopComma(tpPfx + "%d")
  val paramsDecl = paramsLoopComma(subNodePfx + "%d: Exp[" + tpPfx + "%<d]")
  val params = paramsLoopComma(subNodePfx + "%d")
  val interpretParams = paramsLoopComma(subNodePfx + "%d.interpret()")
  %>
///////////////////////////////////////////////////
// SUPPORT FOR OPERATION NODES OF ARITY ${arity} //
///////////////////////////////////////////////////

//Passing Self allows to prevent statically the only boilerplate-related copy-n-paste bug in defining tree classes.
trait Arity${arity}OpTrait[${paramsLoopComma("A%d <: Exp[_]")}, +R, Self <: Exp[R]] extends Exp[R] {<%--
  //Ensure that Self is actually correct: --%>
  this: Self =>
  ${paramsLoop("\n  ")("def " + subNodePfx + "%d: A%<d")}
  override def nodeArity = ${arity}
  def children = Seq(${params})
  def checkedGenericConstructor =
    v => copy(${baseParLoop(arity)(i => "v(%d).asInstanceOf[A%d]" format (i - 1, i))})
<%--
  //Ensure that copy returns the correct type. --%>
  def copy(${paramsLoopComma(subNodePfx + "%d: A%<d")}): Self
}

abstract class Arity${arity}Op[${paramsLoopComma(tpPfx + "%d <: Exp[_]")}, +R, Self <: Exp[R]](${paramsLoopComma("val " + subNodePfx + "%d: A%<d")}) extends Arity${arity}OpTrait[${tparams}, R, Self] {
  this: Self =>
}
<%--
Should this inherit from Arity2OpExpTrait or from Arity2Op? Does it matter? I hope not - these classes should
stay an implementation detail.
--%>
abstract class Arity${arity}OpExp[${tparams}, +R, Self <: Exp[R]](${paramsDecl})
  extends Arity${arity}Op[${paramsLoopComma("Exp[" + tpPfx + "%d]")}, R, Self](${params}) {
  this: Self =>
}

#end
#for (arity <- 1 to maxArity)
<%
  //def paramsLoop(formatStr: String, prefix: String = argPfx) = defParamsLoopOld(arity)(formatStr, prefix)
  val paramsLoop = defParamsLoop(arity) _
  val paramsLoopComma = paramsLoop(commaSpace)

  val tparams = paramsLoopComma(tpPfx + "%d")
  val paramsDecl = paramsLoopComma(argPfx + "%d: Exp[A%<d]")
  val params = paramsLoopComma(argPfx + "%d")
  val interpretParams = paramsLoopComma(argPfx + "%d.interpret()")
  %>
/////////////////////////////////////////
// SUPPORT FOR CALLs OF ARITY ${arity} //
/////////////////////////////////////////

case class Call${arity}[${tparams}, Res](/*val*/ id: Symbol, callfunc: (${tparams}) => Res, ${paramsDecl})
    extends Arity${arity}OpExp[${tparams}, Res, Call${arity}[${tparams}, Res]](${params}) with Call[Res] {
  def copy(${paramsDecl}) = new Call${arity}(id, callfunc, ${params})
  def interpret() = callfunc(${interpretParams})
}

#end
#for (arity <- 2 to maxArity)
<%
  //def paramsLoop(formatStr: String, prefix: String = argPfx) = defParamsLoopOld(arity)(formatStr, prefix)
  val paramsLoop = defParamsLoop(arity) _
  val paramsLoopComma = paramsLoop(commaSpace)

  val tparams = paramsLoopComma(tpPfx + "%d")
  val paramsDecl = paramsLoopComma(argPfx + "%d: Exp[A%<d]")
  val params = paramsLoopComma(argPfx + "%d")
  val interpretParams = paramsLoopComma(argPfx + "%d.interpret()")
  %>
//////////////////////////////////////////
// SUPPORT FOR TUPLES OF ARITY ${arity} //
//////////////////////////////////////////

case class LiftTuple${arity}[${tparams}](${paramsDecl}) extends Arity${arity}OpExp[${tparams}, (${tparams}), LiftTuple${arity}[${tparams}]](${params}) {
  def copy(${paramsDecl}) = LiftTuple${arity}(${params})
  def interpret() = (${interpretParams})
}

#for (i <- 1 to arity)
case class Tuple${arity}Proj${i}[${tparams}](p: Exp[(${tparams})]) extends Arity1OpExp[(${tparams}), A${i}, Tuple${arity}Proj${i}[${tparams}]](p) {
  def copy(p: Exp[(${tparams})]) = Tuple${arity}Proj${i}(p)
  def interpret() = p.interpret()._${i}
}
#end

#end
////////////////////////////////////////////////
// SUPPORT FOR TUPLES - AUTOMATIC CONVERSIONS //
////////////////////////////////////////////////

trait AutoTupleOps {
  this: FunctionOps =>
  #for (arity <- 2 to maxArity)
  ////////////////////////////////////////////
  // AUTOMATIC CONVERSIONS - ARITY ${arity} //
  ////////////////////////////////////////////
  <%
    //def paramsLoop(formatStr: String, prefix: String = argPfx) = defParamsLoopOld(arity)(formatStr, prefix)
    val paramsLoop = defParamsLoop(arity) _
    val paramsLoopComma = paramsLoop(commaSpace)
    val tparams = paramsLoopComma(tpPfx + "%d")
    %>

  implicit def tuple${arity}ToTuple${arity}Exp[${tparams}](tuple: (${paramsLoopComma("Exp[" + tpPfx + "%d]")})): LiftTuple${arity}[${tparams}] =
    LiftTuple${arity}[${tparams}](${paramsLoopComma("tuple._%d")})

  class Tuple${arity}Ops[${tparams}](p: Exp[(${tparams})]) {
    ${defParamsLoop(arity)("\n    ")("def _%d = Tuple" + arity + "Proj%<d(p)")}
  }

  implicit def toTuple${arity}Ops[${tparams}](e: Exp[(${tparams})]): Tuple${arity}Ops[${tparams}] = new Tuple${arity}Ops(e)
  #end
}



  <%--
  DEAD CODE - DO NOT USE
  #set (tparams)
    #for (j <- 1 to arity - 1)
    A${j},
    #end
    A${arity}
  #end
  #set (paramsDecl)
    #for (j <- 1 to arity - 1)
    a${j}: Exp[A${j}],
    #end
    a${arity}: Exp[A${arity}]
  #end--%>
