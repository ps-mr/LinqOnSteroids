package ivm.expressiontree
import annotation.switch

<%
  escapeMarkup = false
  val minTupleArity = 2
  val maxArity = 6
  val commaSpace = ", "
  def baseParLoop(arity: Int)(formatter: Int => String, sep: String = commaSpace) = (1 to arity) map formatter mkString sep
  def defParamsLoop(arity: Int)(sep: String)(formatStr: String) = baseParLoop(arity)(formatStr format _, sep)
  var pIdx = -1
  def defParamsLoopFunc(arity: Int)(sep: String)(body: => Unit) = {
    pIdx = 1
    while (pIdx <= arity) {
      body
      pIdx += 1
    }
  }
  def defParamsLoops(arity: Int) =
    (defParamsLoop(arity) _, (defParamsLoop(arity)(commaSpace)(_)), defParamsLoopFunc(arity) _)

  val tpPfx = "A"
  val argPfx = "t"

  var (paramsLoop, paramsLoopComma, foreachParam) = defParamsLoops(0)

  //These refer to mutable variables, hence must be definitions!
  def tparams = paramsLoopComma(tpPfx + "%d")
  val paramTempl = argPfx + "%d: Exp[" + tpPfx + "%<d]"
  def paramsDecl = paramsLoopComma(paramTempl)
  def paramsDeclOverride = paramsLoopComma("override val " + paramTempl)
  def params = paramsLoopComma(argPfx + "%d")
  def interpretParams = paramsLoopComma(argPfx + "%d.interpret()")
%>
#for (arity <- 1 to maxArity)
<% val p = defParamsLoops(arity); paramsLoop = p._1; paramsLoopComma = p._2 %>
///////////////////////////////////////////////////
// SUPPORT FOR OPERATION NODES OF ARITY ${arity} //
///////////////////////////////////////////////////

//Passing Self allows to prevent statically the only boilerplate-related copy-n-paste bug in defining tree classes.
trait Arity${arity}OpTrait[${paramsLoopComma("A%d <: Exp[_]")}, +R, Self <: Exp[R]] extends Exp[R] {<%--
  //Ensure that Self is actually correct: --%>
  this: Self =>
  ${paramsLoop("\n  ")("def " + argPfx + "%d: A%<d")}
  override def nodeArity = ${arity}
  def children = Seq(${params})
  def checkedGenericConstructor =
    v => copy(${baseParLoop(arity)(i => "v(%d).asInstanceOf[A%d]" format (i - 1, i))})
<%--
  //Ensure that copy returns the correct type. --%>
  def copy(${paramsLoopComma(argPfx + "%d: A%<d")}): Self
}

abstract class Arity${arity}Op[${paramsLoopComma(tpPfx + "%d <: Exp[_]")}, +R, Self <: Exp[R]](${paramsLoopComma("val " + argPfx + "%d: A%<d")}) extends Arity${arity}OpTrait[${tparams}, R, Self] {
  this: Self =>
}
<%--
Should this inherit from Arity2OpExpTrait or from Arity2Op? Does it matter? I hope not - these classes should
stay an implementation detail.
--%>
abstract class Arity${arity}OpExp[${tparams}, +R, Self <: Exp[R]](${paramsDeclOverride})
  extends Arity${arity}Op[${paramsLoopComma("Exp[" + tpPfx + "%d]")}, R, Self](${params}) {
  this: Self =>
}

/////////////////////////////////////////
// SUPPORT FOR CALLs OF ARITY ${arity} //
/////////////////////////////////////////

case class Call${arity}[${tparams}, Res](/*val*/ id: Symbol, callfunc: (${tparams}) => Res, ${paramsDeclOverride})
    extends Arity${arity}OpExp[${tparams}, Res, Call${arity}[${tparams}, Res]](${params}) with Call[Res] {
  def copy(${paramsDecl}) = new Call${arity}(id, callfunc, ${params})
  def interpret() = callfunc(${interpretParams})
}

#end <%-- //We close and reopen the loop because there are no unary tuples. --%>

trait ExpProduct {
  def productArity: Exp[Int]

  //How to implement this? Create the right dynamic node!
  //def productElement(n: Exp[Int]): Exp[Any]
  //Better name prefix?
  def metaProductArity: Int
  def metaProductElement(n: Int): Exp[Any]
}

#for (arity <- minTupleArity to maxArity)
<% val p = defParamsLoops(arity); paramsLoop = p._1; paramsLoopComma = p._2 %>
//////////////////////////////////////////
// SUPPORT FOR TUPLES OF ARITY ${arity} //
//////////////////////////////////////////

case class LiftTuple${arity}[${tparams}](${paramsDeclOverride}) extends Arity${arity}OpExp[${tparams}, (${tparams}), LiftTuple${arity}[${tparams}]](${params}) {
  def copy(${paramsDecl}) = LiftTuple${arity}(${params})
  def interpret() = (${interpretParams})
}

#for (i <- 1 to arity)
case class Tuple${arity}Proj${i}[${tparams}](p: Exp[(${tparams})]) extends Arity1OpExp[(${tparams}), A${i}, Tuple${arity}Proj${i}[${tparams}]](p) {
  def copy(p: Exp[(${tparams})]) = Tuple${arity}Proj${i}(p)
  def interpret() = p.interpret()._${i}
}
#end

#end
////////////////////////////////////////////////
// SUPPORT FOR TUPLES - AUTOMATIC CONVERSIONS //
////////////////////////////////////////////////

trait AutoTupleOps {
  this: LiftingConvs =>
#for (arity <- minTupleArity to maxArity)
  ////////////////////////////////////////////
  // AUTOMATIC CONVERSIONS - ARITY ${arity} //
  ////////////////////////////////////////////
  <% val p = defParamsLoops(arity); paramsLoop = p._1; paramsLoopComma = p._2; foreachParam = p._3 %>

  implicit def tuple${arity}ToTuple${arity}Exp[${tparams}](tuple: (${paramsLoopComma("Exp[" + tpPfx + "%d]")})): LiftTuple${arity}[${tparams}] =
    LiftTuple${arity}[${tparams}](${paramsLoopComma("tuple._%d")})

  class Tuple${arity}Ops[${tparams}](p: Exp[(${tparams})]) {
<% foreachParam("\n    ") { %>
    def _${pIdx}: Exp[${tpPfx}${pIdx}] = p match {
      case LiftTuple${arity}(${params}) => ${argPfx}${pIdx}
      case _ => Tuple${arity}Proj${pIdx}(p)
    }

<% } %>
    def metaProductArity: Int = ${arity}

    def metaProductElement(n: Int): Exp[Any] = (n: @switch) match {
      ${baseParLoop(arity)(i => "case %d => Tuple%dProj%d(p)" format (i - 1, arity, i), "\n      ")}
    }
  }

  implicit def toTuple${arity}Ops[${tparams}](e: Exp[(${tparams})]): Tuple${arity}Ops[${tparams}] = new Tuple${arity}Ops(e)
#end
}

<%
def nothingN(arity: Int) = Seq.fill(arity)("Nothing") mkString ", "
%>
object TupleSupport extends AutoTupleOps with LiftingConvs {
  def projectionTo[T](e: Var, arity: Int, idx: Int): Exp[T] =
    ((arity: @switch) match {
#for (arity <- minTupleArity to maxArity)
      case ${arity} => toTuple${arity}Ops(e.asInstanceOf[Exp[(${nothingN(arity)})]]).metaProductElement(idx)
#end
    }).asInstanceOf[Exp[T]]
}

object TupleSupport2 {
  def projectionTo[T](e: Var, arity: Int, idx: Int): Exp[T] =
    (arity: @switch) match {
      case 1 =>
        idx match {
          case 0 => e.asInstanceOf[Exp[Nothing]]
        }
#for (arity <- minTupleArity to maxArity)
      case ${arity} =>
        (idx: @switch) match {
          ${baseParLoop(arity)(i => "case %d => Tuple%dProj%d(e.asInstanceOf[Exp[(%s)]])" format (i - 1, arity, i, nothingN(arity)), "\n          ")}
        }
#end
    }
  def toTuple(exps: Seq[Exp[_]]): Exp[_] = {
    val arity = exps.length
    (arity: @switch) match {
      case 0 => Const(())
      case 1 => exps(0)
#for (arity <- minTupleArity to maxArity)
      case ${arity} => LiftTuple${arity}(${baseParLoop(arity)(i => "exps(%d)" format i - 1)})
#end
    }
  }
}
