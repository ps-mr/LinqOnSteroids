#import(ivm.generation.ScalaSigHelpers._)
#import(tools.scalap.scalax.rules.scalasig.MethodSymbol)
<%@ val classFile: String %>
<% val className = classFile.split("\\.").last %>
  implicit def expTo${className}Ops(t: Exp[${className}]) = new ${className}Ops(t)
  class ${className}Ops(t: Exp[${className}]) {
<% val scalaSig = getScalaSig(classFile)
   val classSymbol = scalaSig.topLevelClasses.head
   val fil: MethodSymbol => Boolean = s => !(s.name == "<init>" || s.isOverride || s.isPrivate || s.isProtected || s.isSynthetic || s.name.contains("$"))
   val symbols = getMethodSymbols(classSymbol, scalaSig, fil)
   symbols foreach ( n => { %>
    ${getClassifier(n)} ${n.name}${unescape(getTypeParameters(n))}${getParametersAsString(n)}: ${getResultType(n)} = new ${n.name}${getParameterNamesAsString(n, "(", ")")}
<% })
   symbols foreach ( n => { %>
    class ${n.name}${unescape(getTypeParameters(n))}${getParametersAsString(n)} extends Arity${getNumberOfParameters(n)}Exp[${getResultType(n, false)}] {
      def interpret() = t.interpret().${n.name}${getParameterNamesAsString(n, "(", ")", true, false, x => x + ".interpret()")}
    }
<% }) %>
  }
