package ivm.expressiontree


/* The implicit contract: id is a string description of the
   call. In case of a field access it is the name of the field.
   In case of a method call it is the name of the parameter and the types
   of its fields in the format "foo(Int,Int)".
   The point of the id field is to have a non-trivial equality relation on calls, see
   also definition of equals.

   Eventually the id field should be generated by the compiler to ensure consistency.
   We should also have the name of the class declaring the method, so that Base1.name is distinct from Base2.name
   when Base1 and Base2 are unrelated classes.
   When D <: Base1, however, D.name and Base1.name should not be distinguished - if we invoke Base1.name on an instance
   of D, we are in effect invoking D.name. A correct solution is to never generate, in such a case, a wrapper node
   for D.name.
 */
trait Call[Res] extends Def[Res] with MethodPrinting {
  val name: Symbol
  val restId: Symbol
  //val recvManifest: OptManifest[Any /*Recv*/].
  override def equals(other: Any) = other match {
      case that: Call[_] =>
        this.name == that.name &&
        this.restId == that.restId &&
        //this.recvManifest == that.recvManifest &&
        (this.children equals that.children)
      case _ =>
        false
  }
  override def hashCode = 41 * 41 * name.hashCode + 41 * restId.hashCode + children.hashCode
  private def baseName(str: String) = str substring ((str lastIndexOf '.') + 1)
  override def toString = "%s(%s, %s, %s)" format (baseName(getClass.getName), name, restId, children mkString ", ")
  def operator = name.name
}
